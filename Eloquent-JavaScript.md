#Eloquent JavaScript 2nd Edition

##Introduction

Programming language exist so that we can instruct computer how to accomplish a given task, and essentially act as an interface between how we understand commands and the binary language that a computer understands.

##Chapter 1

A value is a reserved collection of bits that represents some piece of information. There are 6 types of values: numbers, strings, Booleans, objects, functions, and undefined. A number value is exactly that: a number. A string value is a sequence of characters, with a "\" preceding special characters. Boolean values are "true" or "false", often generated through an operator comparing other values.

Operators are actions that are performed on values, such as the arithmetic operators. Unary operators only accept one value, binary operators accept 2 values, and ternary will accept 3 values.

JavaScript will engage in automatic type conversion of values if you are not careful, so be aware of how it may be interpreting the values when used with various operators.

##Chapter 2

Variables provide a way of storing values for use later, and the name of the variable can be used in place of the value in all instances after it is declared. multiple variables can be declared at once by using a comma to separate them.

Functions are values that are generated by executing operations on passed values. They can also generate side-effects, such as displaying content. Examples include console.log(), alert(), prompt(), and confirm().

Conditional execution allows for you to create conditions for executing certain parts of a program. If/Else, While, Do/While, For, and Switch/Case are examples of how you can create code to run 0, 1, or multiple times if necessary. Generally conditional code should be wrapped in {} to separate it from the main content block. A "break" command can be included in a conditional to immediately break out of the block and go to the next line in the parent block. When using a switch structure you must include breaks to exit the block.

Comments are useful for denoting the purpose of sections of code so that you or others can easily edit the code later if necessary.

##Chapter 3

Functions can be defined either using "var NAME = function(VALUE) {}" (created function right there) or "function NAME(VALUE) {}" (creates function at beginning of program) with the code for the function going inside the brackets. A function can accept any number of parameters, including none. If not enough parameters are supplied when calling the function,  they default to undefined. If too many are supplied, the extra parameters are ignored. Functions also create a localized scope, meaning that any variables created through the "var" command only exist within the function, even if that variable exists globally outside the function.

Functions can be nested inside each other or made recursive (when a function calls upon itself in its own block). The stack is created as a result of nested functions, with every function being added to the top and the stack always being resolved top-down.

Creating new functions should occur when they have a clearly defined purpose and the code within them will need to be used multiple times within the program. Functions can have a side effect and/or return a value. A side effect is when a function performs some action other than returning a value that is useful, such as printing specific text. A pure function is one that has no side effects and relies ONLY on local variables, such that it always produces the same results when given the same parameters.

##Chapter 4

An array allows a user to store a sequence of values using the notation "var NAME = [V0, V1, V2, V3, V4, ...]" A specific value of an array can be accessed using NAME[#]. NAME.push(VX) can be used to add the value VX to the end of array NAME. NAME.pop removes the last value from an array and returns it. NAME.join "TEXT" takes an array of strings and combines them into one string, inserting TEXT between each of them.

Objects allow a user to store a list of properties (written as "NX:EX"), written as "var NAME = {N0:E0, N1:E1, N2:E2, ...}". An expression can be called by using "NAME.NX" to call up expression EX. "delete NAME.NX" can be used to remove a property from an object. "NX in NAME" can be used to determine if NX exists in NAME. Objects are only equal if they have been defined to be so; i.e. 2 objects separately defined with the exact same properties are not equal.

indexof(VX) will return the first array index of VX. lastindexof(VX) will return the last array index of VX. slice(X,Y) will return an array starting at index X and ending just before index Y. If no Y value is given, it will continue to the end of the array. ARRAY1.concat(ARRAY2) will return an array with the ARRAY2 added to the end of ARRAY1.

##Chapter 5

Functions should be created to abstract concepts so that the core program is more intuitive. While this may make a program slightly longer, it makes it less bug prone since you will be able to test each individual element before combining them into a whole. Also, each level of abstraction will cause the program to be less efficient, making it take longer to complete the task, but this inefficiency is often negligible when compared to human reaction speed.

"ARRAY.forEach(function(X) {})" can be used to contain a for loop that would act on each element in an array, where each element will be named X inside the inner function. Using this notation it is possible to nest function, create functions inside others, and have functions edit other functions. The key to this is remembering that a function is just a value.

JSON is an object array where every property name and value must be in quotations, allowing it to be turned into a string via .stringify or parsed back into an object using .parse.

Other useful methods include .map (creates an array from an object using a set of criteria) and .filter (creates new object by removing properties that don't fit criteria).

##Chapter 6

Methods are properties that hold function values, allowing you to execute the given function easily on the object by using OBJECT.METHOD(). "this.NAME" can be used in a method to return the value of the property with the NAME.

Prototypes are essentially base versions of objects. Any properties of a prototype will be passed onto objects with that prototype, though they can be specifically overwritten. You can call the prototype of an object using OBJECT.prototype. You can create a "child" of a prototype by using "var OBJECT = Object.create(PROTOTYPE)." Essentially a prototype provides default properties. When using Object.create, the new object will inherit all properties, including constructors, of the prototype.

Constructors are functions that are called with the "new" keyword preceding them, and serve the purpose of creating new objects. Any instances of "this" inside the constructor will refer to the object being created.

Prototypes can have enumerable and nonenumerable properties. Enumerable properties will show up in a for/in loop despite not existing in the object itself. By using "Object.defineProperty(Object.prototype, "NAME", {enumerable: true/false, value:VALUE})" you can set the enumeration of a prototype property. The "in" operator will still return nonenumerable properties, but you can use the .hasOwnProperty method see if the specific object has that property. To avoid prototype properties altogether, use "var OBJECT = Object.create(null)".

Polymorphism allows you to to use the .toString method to define specific ways of transforming values into strings as long as they fit the format being used, such as creating a table out of an array of arrays.

Getters and setters allow you to define a method that is only accessed when used. Getters trigger when you pass no argument in the method, while setters trigger when you define the argument.

The "instanceOf" operator can be used to determine if an object was derived from a constructor in the format "new OBJECT() instanceOf CONSTRUCTOR". Essentially this will return true of the constructor is the prototype of the object.

##Chapter 8

JavaScript is in general terrible for debugging because it is not a strict language. This means that errors may be passed along as it tries to interpret them even though they are no longer meaningful. To avoid this you can start your program with "use strict";, which will cause it to require every value to be defined and help identify potential problem areas. It also causes the "this" binding to be undefined outside of methods (since by default "this" would not be referring to anything). It also has other effects.

Testing for errors can be done using if statements, but can become cumbersome and repetitive. A well-placed console.log command can help identify errors, particularly in a function or a for loop. You can also use breakpoints in your browser's debugging software to pause the program, allowing you to inspect the various values in that snapshot.

While programs for personal use can encounter errors that cause them to crash, this is generally not acceptable when others will be using your program. Thus it is prudent to include code that notifies the user of the error and either prompts to fix the mistake or simply shuts the program down.

Exception Handling is another way to debug software using the commands try, catch, and throw along with the Error constructor. Essentially you place a throw command with the Error constructor in a place the program will only reach if an error occurs. Upon reaching the next try/catch command pair, if an error was thrown it will run the catch command. Otherwise it will run the try command. This allows you to test for errors in specific locations. The finally command can be used with try to ensure that a specific piece of code ALWAYS runs, regardless of an error being thrown or not.

Do not use the try/catch system to blanket catch errors, but rather design it to indicate the specific error as best as possible (usually with a "throw e;" command).

Assertions are functions designed to catch errors, usually by having a test condition that, if failed, returns a message.

##Chapter 9
