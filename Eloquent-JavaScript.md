#Eloquent JavaScript 2nd Edition

##Introduction

Programming language exist so that we can instruct computer how to accomplish a given task, and essentially act as an interface between how we understand commands and the binary language that a computer understands.

##Chapter 1

A value is a reserved collection of bits that represents some piece of information. There are 6 types of values: numbers, strings, Booleans, objects, functions, and undefined. A number value is exactly that: a number. A string value is a sequence of characters, with a "\" preceding special characters. Boolean values are "true" or "false", often generated through an operator comparing other values.

Operators are actions that are performed on values, such as the arithmetic operators. Unary operators only accept one value, binary operators accept 2 values, and ternary will accept 3 values.

JavaScript will engage in automatic type conversion of values if you are not careful, so be aware of how it may be interpreting the values when used with various operators.

##Chapter 2

Variables provide a way of storing values for use later, and the name of the variable can be used in place of the value in all instances after it is declared. multiple variables can be declared at once by using a comma to separate them.

Functions are values that are generated by executing operations on passed values. They can also generate side-effects, such as displaying content. Examples include console.log(), alert(), prompt(), and confirm().

Conditional execution allows for you to create conditions for executing certain parts of a program. If/Else, While, Do/While, For, and Switch/Case are examples of how you can create code to run 0, 1, or multiple times if necessary. Generally conditional code should be wrapped in {} to separate it from the main content block. A "break" command can be included in a conditional to immediately break out of the block and go to the next line in the parent block. When using a switch structure you must include breaks to exit the block.

Comments are useful for denoting the purpose of sections of code so that you or others can easily edit the code later if necessary.

##Chapter 3

Functions can be defined either using "var NAME = function(VALUE) {}" (created function right there) or "function NAME(VALUE) {}" (creates function at beginning of program) with the code for the function going inside the brackets. A function can accept any number of parameters, including none. If not enough parameters are supplied when calling the function,  they default to undefined. If too many are supplied, the extra parameters are ignored. Functions also create a localized scope, meaning that any variables created through the "var" command only exist within the function, even if that variable exists globally outside the function.

Functions can be nested inside each other or made recursive (when a function calls upon itself in its own block). The stack is created as a result of nested functions, with every function being added to the top and the stack always being resolved top-down.

Creating new functions should occur when they have a clearly defined purpose and the code within them will need to be used multiple times within the program. Functions can have a side effect and/or return a value. A side effect is when a function performs some action other than returning a value that is useful, such as printing specific text. A pure function is one that has no side effects and relies ONLY on local variables, such that it always produces the same results when given the same parameters.

##Chapter 4

An array allows a user to store a sequence of values using the notation "var NAME = [V0, V1, V2, V3, V4, ...]" A specific value of an array can be accessed using NAME[#]. NAME.push(VX) can be used to add the value VX to the end of array NAME. NAME.pop removes the last value from an array and returns it. NAME.join "TEXT" takes an array of strings and combines them into one string, inserting TEXT between each of them.

Objects allow a user to store a list of properties (written as "NX:EX"), written as "var NAME = {N0:E0, N1:E1, N2:E2, ...}". An expression can be called by using "NAME.NX" to call up expression EX. "delete NAME.NX" can be used to remove a property from an object. "NX in NAME" can be used to determine if NX exists in NAME. Objects are only equal if they have been defined to be so; i.e. 2 objects separately defined with the exact same properties are not equal.

indexof(VX) will return the first array index of VX. lastindexof(VX) will return the last array index of VX. slice(X,Y) will return an array starting at index X and ending just before index Y. If no Y value is given, it will continue to the end of the array. ARRAY1.concat(ARRAY2) will return an array with the ARRAY2 added to the end of ARRAY1.

##Chapter 5

Functions should be created to abstract concepts so that the core program is more intuitive. While this may make a program slightly longer, it makes it less bug prone since you will be able to test each individual element before combining them into a whole. Also, each level of abstraction will cause the program to be less efficient, making it take longer to complete the task, but this inefficiency is often negligible when compared to human reaction speed.

"ARRAY.forEach(function(X) {})" can be used to contain a for loop that would act on each element in an array, where each element will be named X inside the inner function. Using this notation it is possible to nest function, create functions inside others, and have functions edit other functions. The key to this is remembering that a function is just a value.

JSON is an object array where every property name and value must be in quotations, allowing it to be turned into a string via .stringify or parsed back into an object using .parse.

Other useful methods include .map (creates an array from an object using a set of criteria) and .filter (creates new object by removing properties that don't fit criteria).

Notable methods: ARRAY.forEach(function(X) {}) will iterate over the array, passing each value as an argument to the function and naming it X (or whatever else you have named the argument for the function). ARRAY.filter(function(X) {}) works like .forEach except that it creates a new array built on the returned truth value of the inner function. ARRAY.map(function(X) {}) also works like .forEach, but creates a new array built from the returns of the inner function. ARRAY.reduce(function(A,B) {}) performs an iterative function where B is the current element and A is the result of the previous iteration.

##Chapter 6

Methods are properties that hold function values, allowing you to execute the given function easily on the object by using OBJECT.METHOD(). "this.NAME" can be used in a method to return the value of the property with the NAME.

Prototypes are essentially base versions of objects. Any properties of a prototype will be passed onto objects with that prototype, though they can be specifically overwritten. You can call the prototype of an object using OBJECT.prototype. You can create a "child" of a prototype by using "var OBJECT = Object.create(PROTOTYPE)." Essentially a prototype provides default properties. When using Object.create, the new object will inherit all properties, including constructors, of the prototype.

Constructors are functions that are called with the "new" keyword preceding them, and serve the purpose of creating new objects. Any instances of "this" inside the constructor will refer to the object being created.

Prototypes can have enumerable and nonenumerable properties. Enumerable properties will show up in a for/in loop despite not existing in the object itself. By using "Object.defineProperty(Object.prototype, "NAME", {enumerable: true/false, value:VALUE})" you can set the enumeration of a prototype property. The "in" operator will still return nonenumerable properties, but you can use the .hasOwnProperty method see if the specific object has that property. To avoid prototype properties altogether, use "var OBJECT = Object.create(null)".

Polymorphism allows you to to use the .toString method to define specific ways of transforming values into strings as long as they fit the format being used, such as creating a table out of an array of arrays.

Getters and setters allow you to define a method that is only accessed when used. Getters trigger when you pass no argument in the method, while setters trigger when you define the argument.

The "instanceOf" operator can be used to determine if an object was derived from a constructor in the format "new OBJECT() instanceOf CONSTRUCTOR". Essentially this will return true if the constructor is the prototype of the object.

Call and apply are methods on a method that allows you to target a specific object instead of the default for the 1st method. Both take the first argument as the target. Call takes other arguments for the method as comma separated, while apply takes other arguments as an array. Bind is similar except that it returns a new function with "this" ALWAYS changed to the target.

##Chapter 8

JavaScript is in general terrible for debugging because it is not a strict language. This means that errors may be passed along as it tries to interpret them even though they are no longer meaningful. To avoid this you can start your program with "use strict";, which will cause it to require every value to be defined and help identify potential problem areas. It also causes the "this" binding to be undefined outside of methods (since by default "this" would not be referring to anything). It also has other effects.

Testing for errors can be done using if statements, but can become cumbersome and repetitive. A well-placed console.log command can help identify errors, particularly in a function or a for loop. You can also use breakpoints in your browser's debugging software to pause the program, allowing you to inspect the various values in that snapshot.

While programs for personal use can encounter errors that cause them to crash, this is generally not acceptable when others will be using your program. Thus it is prudent to include code that notifies the user of the error and either prompts to fix the mistake or simply shuts the program down.

Exception Handling is another way to debug software using the commands try, catch, and throw along with the Error constructor. Essentially you place a throw command with the Error constructor in a place the program will only reach if an error occurs. Upon reaching the next try/catch command pair, if an error was thrown it will run the catch command. Otherwise it will run the try command. This allows you to test for errors in specific locations. The finally command can be used with try to ensure that a specific piece of code ALWAYS runs, regardless of an error being thrown or not.

Do not use the try/catch system to blanket catch errors, but rather design it to indicate the specific error as best as possible (usually with a "throw e;" command).

Assertions are functions designed to catch errors, usually by having a test condition that, if failed, returns a message.

##Chapter 9 Regular Expressions

Regular expressions are ways to check for patterns in strings, allowing you to inspect, process, and filter them. A regular expression takes the form "/REGEXP/". There are many methods to be used with regular expressions, and many special characters to include for more detailed searching. At it's core, a regular expression is equivalent to any string that contains the contents of the regexp. For example, /th/ is equivalent to "thought" and "math" but not "sought" or "hat"

|Method|Purpose|
|---|---|
|REGEXP.test("STRING")|Returns truth value of equivalency between regexp and string|
|REGEXP.exec("STRING")|Returns the matching information and its index number; return null if no match|
|"STRING".match(REGEXP)|Same as exec|
|"STRING".replace(REGEXP or "STRING","STRING")|Searches the first string for all instances of the first argument and replaces them with the second argument|
|"STRING".search(REGEXP)|Returns the first index of the expression, or -1 if not found|

|Syntax|Description|
|---|---|
|/abc/|A sequence of characters|
|/[abc]/|Any character from a set of characters|
|/[^abc]/|Any character not from a set of characters|
|/[0-9]/|Any character in a range of characters|
|/x+/|One of more occurrences of the pattern x|
|/x+?/|As above but not greedy|
|/x*/|Zero of more occurrences of x|
|/x?/|Zero or one occurrence|
|/x{2,4}/|Between 2 and four occurrences|
|/(abc)/|A group|
|/\d/|Any digit character, capitalize for negation|
|/\w/|An alphanumeric character, capitalize for negation|
|/\s/|Any whitespace character, capitalize for negation|
|/./|Any character except newlines|
|/\b/|A word boundary|
|/^/|Start of input|
|/$/|End of input|

##Chapter 10 Modules

Modules are a special form of function used to prevent cluttering namespace in a program (i.e. avoiding reuse of variable names). The idea is to create functions that do not change in how they are called or the type of information they return even as you update them, meaning that any references to them in your programs will be able to continue using them (also known as having a "stable" interface).

Other than simply using standard functions you can also wrap a function in parentheses, which causes JavaScript to treat it as an expression and thus does not require a name. This also means that the expression will be completely self-encased. Nothing from outside the expression will be able to access it, causing it to run wherever it is in the code with no effect on anything else. It would take the format of (function (){MODULE})();

You can also create interfaces using modules. This allows you to have a general function with an interface system that allows you to alter how the module behaves. As a module is updates, additional interfaces can be added without affecting existing ones. Since this can become cumbersome in large modules, it is common to use an "exports" object and build the interface as its properties.

To avoid confusion if 2 modules have the same name, you can create a separate file and use a "readFile" function to retrieve it. This allows you to avoid accidentally calling another module that may have the same name. However, "readFile" will only return a string. One way to read it as code is to use the "eval" operator, but this breaks the local scope of the module. Another way is to use the "Function" constructor, written as: "new Function("ARGUMENTS","CODE")". You can replace "CODE" with readFile(NAME) when using the readFile function. Because the module is called within a function, the file being read does not need to contain the function wrapping.

The "require" function is part of node.js and causes the program to load the module within. Loading each module individually can be cumbersome for the code, however, especially if there are interdependencies. A modules that requires other modules and is run more than once will load its dependencies each times it is run. To get around this you can create a modules object with exports as a property.

Because nothing else can happen while a script is running, loading several modules during a script can cause a website to freeze. To prevent this you can either use Browserify (which will load all dependencies into a single file) or AMD (which will load dependencies in the background before running a function) The AMD system uses "define" to load modules, with the module written as "define([],function(){CODE});" A "getModule" function can be written to to check if a module has already been loaded by storing loaded modules in a "cache" object and checking to see if a module already exists when being called.

When creating modules try to keep their purpose as clear as possible. Making a catch-all module defeats the purpose as it makes it hard for others to understand your code. Also, try to keep modules simple and pure when possible. Modules should be specialized for the task at hand instead of trying to do everything themselves. Another suggestions is to make layered interfaces, where you design the detailed interface first and then create simpler versions of it for others to use containing the most commonly used parts of the interface.

For more information see Immediate Invoke Function Expression.

##Chapter 12

In addition to the ways we have already learned to include javascript in a page using script, you can also use the attribute onclick="JS" in a button element. Web pages on the internet operate in a sandbox, meaning that they cannot manipulate  anything outside of the webpage they are embedded in. This results in an isolated programming environment.

In the early days a single browser would dominate the internet, but with the advent of Firefox, Chrome, and Safari there are now 4 major players that are much more concerned with cross-compatibility. Previously the dominant browser at the time would dictate web development to the detriment of other browsers.

##Chapter 13

JavaScript is inserted into a html document by using the script tag. This can be used to either enclose the code or link to a separate file that contains your code.

References to elements in the html document take the form of "document", i.e. document.body will access the body element. JavaScript refers to these elements as nodes. "document.documentElement" refers to the object that represents the html tag (the entire html document). Every node has a nodeType property, which is a numeric identifier: regular elements = 1 (document.ELEMENT_NODE), text nodes = 3 (document.TEXT_NODE), and comments = 8 (document.COMMENT_NODE). Essentially you can imagine elements in html as being objects in JavaScript, with child elements being sub-objects of the main object.

The following properties are all fairly self-explanatory, returning the elements they describe: .childNodes, .lastChild, .firstChild, .previousSibling, and .nextSibling. If no such element exists, then the property returns null. The .nodeValue property refers to the contents of the element. An important method is .getElementsByTagName("TAG"), which creates an array containing all of the nodes of that element. Also .getElementById("ID") can be used to directly access an element with an id attribute. Finally .getElementsByClassName("CLASS") works as expected.

Several methods allow you to edit the html, such as .removeChild(NODE) and .appendChild(NODE). The .insertBefore(NODE1,NODE2) method inserts NODE1 immediately before NODE2. The .replaceChild(NODE1,NODE2) method works the same except it replaces NODE2.
Note that a given node can only exist once, so NODE1 will no longer exist in its original location. Others include .createTextNode(NODE) and .createElement(NODE). .textContent returns the contents of a text node.

To add attributes to a node, use the .setAttribute("ATTRIBUTE"). The .getAttribute("ATTRIBUTE") method will read the value of the indicated attribute. Many attributes can be accessed directly via their name (body.style will access the style attribute of the body element); however, class is a reserved word in JavaScript so you instead use .className to access it.

##Chapter 14

Handlers allow JavaScript to react to button presses instead of having to constantly poll the system to detect a button press. The .addEventListener("EVENT",FUNCTION) is a method attached to a node that executes the FUNCTION when the EVENT is triggered. The method .removeEventListener("EVENT",FUNCTION) is used to remove a handler previously added.

Event objects are objects that contain all of the details of the event that occurred. For example the EVENT.which property gives information on the event that occurred, while the EVENT.target property gives the node where the event occurred.

Propagation determines the order in which event handlers occur, notably that the handler most specific to the node always occurs first, with parent handlers occurring in order as they are further removed from the original node. To stop the propagation, the method EVENT.stopPropagation() is used within the handler method. There are also many default actions that take place on a page, such as right-click bringing up the context menu. These always occur after handlers specified in JavaScript, and can be stopped using the EVENT.preventDefault() method.

For keyboard input, the "keydown" and "keyup" events have the expected function, but note that "keydown" actions will repeat so be careful. When trying to register text that a user is typing, instead of using keydown use "keypress". It functions like keydown but only for keys that produce character input. You can then use String.fromCharCode(EVENT.charCode) to retrieve the text as a string.

"mousedown" triggers when you press a mouse key while the cursor is over the element, "mouseup" triggers when you release the mouse button while the cursor is over an object, and "click" requires both mousedown AND mouseup on the same node before triggering. Finally "dblclick" requires 2 clicks in rapid succession. All of the mouse events log their location, accessable through the EVENT.pageX and EVENT.pageY properties which return the number of pixels offset from the top-left corner of the document. EVENT.clientX and EVENT.clientY are similar but instead relative to the part of the document currently scrolled into view. "mousemove" can be used to keep track of the movement of the cursor, and references are usually contained within a reference to "mousedown" for drag-and-drop functionality. "mouseover" and "mouseout" events trigger when a cursor enters of leaves a node irrespective of actually pressing a button, but be careful of propagation.

The "scroll" event triggers when a user scrolls an element, which is useful for stopping animations that may no longer be visible. "focus" fires when a user focuses on an element, such as a form, and "blur" fires when the element loses focus.

The property EVENT.keyCode returns a numeric identifier for the key actually pressed. For most keys number is the unicode for the number or uppercase letter corresponding to the key, which can also be found using "A".charCodeAt(0). For the shift, ctrl, alt and meta (command on Mac) keys, use EVENT.shiftKey, EVENT.ctrlKey, EVENT.altKey, and EVENT.metaKey respectively.

The var TIMEOUT setTimeout(function(){},TIME); function can be used to execute code after a specified number of milliseconds. clearTimeout(TIMEOUT) can be used to cancel a timeout you have set, and cancelAnimationFrame works the same but for cancelling a requestAnimationFrame function.

|Event Name|Trigger|
|---|---|
|"keydown"|Pressing down on a key|
|"keyup"|releasing a key|
|"keypress"|Like keydown, but useful to log multiple keystrokes|
|"mousedown"|Pressing a mouse button with the cursor over the node|
|"mouseup"|Releasing a mouse button with the cursor over the node|
|"click"|Pressing and releasing a mouse button while the cursor is still over the node|
|"dblclick"|2 clicks in rapid succession|
|"mousemove"|Registers movement of the mouse|
|"mouseover"|When cursor moves into the space of a node|
|"mouseout"|When cursor leaves the space of a node|
|"scroll"|Scrolling an element|
|"focus"|When focus is brought to a node such as a form|
|"blur"|When focus leaves a node|
|"load"|When a page finishes loading|
|"beforeunload"|When a page is closed of navigated away from|

##Chapter 17

HTTP (HyperText Transfer Protocol) is used to send and receive information through a network. A request looks like this:
GET /17_http.html HTTP/1.1      | GET contains the path to the file being requests, HTTP contains the http version
Host: eloquentjavascript.net    | The domain being accessed
User-Agent: Your browser's name | Your browser

In return the server will send the following headers:
HTTP/1.1 200 OK                 | Version return and 3-number status code, 400+ means an error of some sort
Content-Length: 65585           | Size of the file in bytes
Content-Type: text/html         | Type of file
Last-Modified: DATE             | Other information
                                |
BODY                            | The actual file

A server can send more or fewer headers depending on user request and server compliance.

HTML forms that use the get attribute will send a get request with the contents of the form sent following the path and separated by a ?. It may also require escaping characters using unicode references. The encodeURIComponent("STRING") and decodeURIComponent("STRING") can be used to switch to and from this encoding. A post method will, instead of sending the contents attached to the path, place it in the body of the message.

The var REQUEST = XMLHttpRequest() constructor is used to establish a request. Afterwards the REQUEST.open("TYPE", "PATH", TF) is used to tailor the request, with TYPE being the type of request (get, post, etc.), PATH being the path to the file requested, and TF being true for asynchronous requests and false for synchronous requests. This is then followed by REQUEST.send(BODY) will attach the body to the request (typically null) and actually send the request. Finally REQUEST.responseText will return the body of the file requested.

Asynchronous requests allow a program to continue after a request is sent without having to wait for the server to respond. While this can improve the loading speed of a javascript program, it can also cause problems if it encounters code dependent on the request. For this reason you should wrap any code dependent on the request in a "load" event. Error handling on asynchronous requests is tricky since the callback function that will throw the error may not run until the code has already passed the try/catch block. Instead placing the callback function in a "load" event can allow detection of a failure to load the requested file.

For security reasons, the vast majority of websites will not allow http requests to other domains.

A common convention is to abstract XMLHttpRequest into another function so that you do now have to constantly rewrite the same code. Simply create a function that takes the url and the desired callback function and runs it through the XML request code.

A promise is a constructor that provides an interface for error detection in asynchronous code. It is written as "return new Promise(function(succeed,fail){})" with succeed and fail being defined within the constructor. Succeed is used to return the desired result, while fail is used to return a failed result. It essentially acts as an internal wrapper to a function, so the normal code for the function will be contained within the promise. This then allows the primary function to have a few additional methods: "then(function(){},function(){})" will execute the first function if the promise succeeds or the second function if is fails.

##Chapter 18

Form fields typically appear inside a form tag in html, but can also appear anywhere in a web page. While they can only be submitted if inside a form element, JavaScript is capable of interacting with them without actual submission. Each input element will have a value property that contains the information the user has entered. When wrapped in a form element, each input will also have a form property that points to the form element itself. The name attribute of an input can be used as a property on the form element to access the input element.

It is possible to force focus to or away from a form field by using the .focus() and .blur() methods. This can also be done using the "autofocus" attribute in html. The "tabindex=X" attribute can be used to control the order in which a user will cycle through form fields when using the tab key. The "change" event will fire in a text field when it loses focus after the content has been changed. For immediate reaction the "input" event will respond for every change as it occurs.

With the radio input type, a single name attribute is used for multiple radio elements to link them together. The .getElementsByName("NAME") is often used to return an array of all radio elements with the specified name. The select tag is similar to radio, but its appearance is determined by the browser rather than the developer. It can have a functionality similar to checkboxes if the multiple attribute is applied.

Any information in javascript is cleared when the page is reloaded. To store information past this point you can use localStorage.setItem("NAME","VALUE") to create a property for the localStorage object. This will persist until you use localStorage.removeItem("NAME") to remove a property. localStorage is unique to each domain.
